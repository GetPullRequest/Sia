import { createTemporalClient } from '../temporal/client';
import { queueMonitorWorkflow } from '../temporal/workflows/queue-monitor-workflow';
import { setQueuePaused } from '../temporal/activities/queue-status-activity';

export class QueueWorkflowService {
  /**
   * Create or update a schedule for queue monitoring for a specific agent
   * Uses Temporal Schedules instead of long-running workflows
   * Each agent has one schedule that monitors both queues
   */
  async startQueueSchedule(agentId: string): Promise<{ scheduleId: string }> {
    const client = await createTemporalClient();
    const scheduleId = `queue-schedule-${agentId}`;

    try {
      // Check if schedule already exists
      const handle = client.schedule.getHandle(scheduleId);
      await handle.describe();
      // Schedule exists, return existing scheduleId
      console.log(`   Schedule ${scheduleId} already exists`);
      return { scheduleId };
    } catch {
      // Schedule doesn't exist, create it
    }

    try {
      console.log(`   Creating Temporal schedule: ${scheduleId}`);
      await client.schedule.create({
        scheduleId,
        spec: {
          intervals: [{ every: '1m' }], // Run every 1 minute
        },
        action: {
          type: 'startWorkflow',
          workflowType: queueMonitorWorkflow,
          args: [{
            agentId,
          }],
          taskQueue: 'job-queue',
          // WorkflowId will be auto-generated by Temporal for each execution
          // This ensures each scheduled run is independent
          workflowExecutionTimeout: '5 minutes', // Monitor workflow should complete quickly
          workflowRunTimeout: '2 minutes', // Individual run timeout
        },
        policies: {
          overlap: 'SKIP', // Skip if previous execution is still running
          // This ensures that if a workflow is still executing (claiming/executing a job),
          // the next scheduled tick will be skipped, preventing overlapping executions
        },
      });

      console.log(`   ✅ Successfully created schedule: ${scheduleId}`);
      return { scheduleId };
    } catch (error) {
      // If schedule already exists (race condition from another instance)
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('already exists') || 
          errorMessage.includes('AlreadyExists')) {
        console.log(`   Schedule ${scheduleId} was created by another instance`);
        return { scheduleId };
      }
      // Re-throw other errors
      throw error;
    }
  }

  /**
   * Delete a schedule (used when we lose the race condition)
   */
  async deleteSchedule(scheduleId: string): Promise<void> {
    const client = await createTemporalClient();
    try {
      const handle = client.schedule.getHandle(scheduleId);
      await handle.delete();
    } catch (error) {
      // Schedule might not exist, that's fine
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.includes('not found') && !errorMessage.includes('NotFound')) {
        throw error;
      }
    }
  }

  /**
   * Pause a queue schedule for an agent
   * This sets the pause state in the database, which the monitor workflow checks
   */
  async pauseQueue(orgId: string, queueType: 'rework' | 'backlog'): Promise<void> {
    // Set pause state in database (the workflow checks this)
    // Note: Pause is per org/queueType, not per agent
    await setQueuePaused({ orgId, queueType, isPaused: true });
  }

  /**
   * Resume a queue schedule for an agent
   */
  async resumeQueue(orgId: string, queueType: 'rework' | 'backlog'): Promise<void> {
    // Set pause state in database
    // Note: Resume is per org/queueType, not per agent
    await setQueuePaused({ orgId, queueType, isPaused: false });
  }

  /**
   * Pause schedule for an agent
   */
  async pauseAgentSchedules(agentId: string): Promise<void> {
    const client = await createTemporalClient();
    const scheduleId = `queue-schedule-${agentId}`;
    
    try {
      const handle = client.schedule.getHandle(scheduleId);
      await handle.pause();
    } catch (error) {
      // Schedule might not exist, that's fine
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.includes('not found') && !errorMessage.includes('NotFound')) {
        console.warn(`Failed to pause schedule ${scheduleId}:`, errorMessage);
      }
    }
  }

  /**
   * Resume schedule for an agent
   */
  async resumeAgentSchedules(agentId: string): Promise<void> {
    const client = await createTemporalClient();
    const scheduleId = `queue-schedule-${agentId}`;
    
    try {
      const handle = client.schedule.getHandle(scheduleId);
      await handle.unpause();
    } catch (error) {
      // Schedule might not exist, that's fine
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.includes('not found') && !errorMessage.includes('NotFound')) {
        console.warn(`Failed to resume schedule ${scheduleId}:`, errorMessage);
      }
    }
  }

  /**
   * Start schedule for an agent
   * This is called when an agent is created or activated
   */
  async startAgentSchedules(agentId: string): Promise<void> {
    try {
      await this.startQueueSchedule(agentId);
      await this.startHealthCheckSchedule(agentId);
    } catch (error) {
      console.error(`Failed to start schedule for agent ${agentId}:`, error);
    }
  }

  /**
   * Create or update a health check schedule for an agent
   */
  async startHealthCheckSchedule(agentId: string): Promise<{ scheduleId: string }> {
    const client = await createTemporalClient();
    const scheduleId = `health-check-schedule-${agentId}`;

    try {
      const handle = client.schedule.getHandle(scheduleId);
      await handle.describe();
      console.log(`   Health check schedule ${scheduleId} already exists`);
      return { scheduleId };
    } catch {
      // Schedule doesn't exist, create it
    }

    try {
      const { agentHealthCheckWorkflow } = await import('../temporal/workflows');
      console.log(`   Creating health check schedule: ${scheduleId}`);
      await client.schedule.create({
        scheduleId,
        spec: {
          intervals: [{ every: '5m' }], // Run every 5 minutes
        },
        action: {
          type: 'startWorkflow',
          workflowType: agentHealthCheckWorkflow,
          args: [{
            agentId,
          }],
          taskQueue: 'job-queue',
          workflowExecutionTimeout: '30 seconds',
          workflowRunTimeout: '20 seconds',
        },
        policies: {
          overlap: 'SKIP',
        },
      });

      console.log(`   ✅ Successfully created health check schedule: ${scheduleId}`);
      return { scheduleId };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('already exists') || 
          errorMessage.includes('AlreadyExists')) {
        console.log(`   Health check schedule ${scheduleId} was created by another instance`);
        return { scheduleId };
      }
      throw error;
    }
  }

  /**
   * Pause health check schedule for an agent
   */
  async pauseHealthCheckSchedule(agentId: string): Promise<void> {
    const client = await createTemporalClient();
    const scheduleId = `health-check-schedule-${agentId}`;
    
    try {
      const handle = client.schedule.getHandle(scheduleId);
      await handle.pause();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.includes('not found') && !errorMessage.includes('NotFound')) {
        console.warn(`Failed to pause health check schedule ${scheduleId}:`, errorMessage);
      }
    }
  }
}

export const queueWorkflowService = new QueueWorkflowService();

